---
title: Property Graphs
description: GraphAcademy
sidebar:
  order: 2
tableOfContents:
  minHeadingLevel: 2
  maxHeadingLevel: 4
---
import { Aside } from '@astrojs/starlight/components';

## What is a Property Graph?

### Property Graph

In the previous module we referred to nodes and relationships as the fundamental building blocks for a graph. In this lesson you will learn about the additional elements that Neo4j supports to make a property graph.

#### Nodes, Labels and Properties
Recall that nodes are the graph elements that represent the things in our data. We can use two additional elements to provide some extra context to the data.

Let’s take a look at how we can use these additional elements to improve our social graph.



#### Labels

![labels](/img/neo4j/labels.png)

By adding a label to a node, we are signifying that the node belongs to a subset of nodes within the graph. Labels are important in Neo4j because they provide a starting point for a Cypher statement.

Let’s take Michael and Sarah - in this context both of these nodes are persons.

We can embellish the graph by adding more labels to these nodes; Michael identifies as male and Sarah is female. In this context, Michael is an employee of a company, but we don’t have any information about Sarah’s employment status.

Michael works for a company called Graph Inc, so we can add that label to the node that represents a company.

<Aside type="note" title="">
In Neo4j, a node can have zero, one, or many labels.
</Aside>

#### Node properties

So far we’re assuming that the nodes represent Michael, Sarah, and Graph Inc. We can make this concrete by adding properties to the node.

Properties are key, value pairs and can be added or removed from a node as necessary. Property values can be a single value or list of values [that conform to the Cypher type system](https://neo4j.com/docs/cypher-manual/current/values-and-types/property-structural-constructed/).

![properties](/img/neo4j/properties.png)

By adding `firstName` and `lastName` properties, we can see that the Michael node refers to Michael Faraday, known for Faraday’s law of induction, the Faraday cage and lesser known as the inventor of the Party Balloon. Michael was born on 22 September 1791.

Sarah’s full name is Sarah Faraday, and her `maidenName` is Barnard.

By looking at the `name` property on the Graph Inc node, we can see that it refers to the company Graph Inc, with a `city` of London, has 56 employees (`numEmployees`), and does business as Graph Incorporated and GI (`dba`).

<Aside type="note" title="">
Properties do not need to exist for each node with a particular label. If a property does not exist for a node, it is treated as a `null` value.
</Aside>

### Relationships

A relationship in Neo4j is a connection between two nodes.

#### Relationship direction

![direction](/img/neo4j/direction.png)

In Neo4j, each relationship must have a direction in the graph. Although this direction is required, the relationship can be queried in either direction, or ignored completely at query time.

A relationship is created between a source node and a destination node, so these nodes must exist before you create the relationship.

If we consider the concept of directed & undirected graphs that we discussed in the previous module, the direction of the `MARRIED_TO` relationship must exist and may provide some additional context but can be ignored for the purpose of the query. In Neo4j, the `MARRIED_TO` relationship must have a direction.

The direction of a relationship can be important when it comes to hierarchy, although whether the relationships point up or down towards the tree is an arbitrary decision.

#### Relationship type

![Relationships with types](/img/neo4j/rt.png)

Each relationship in a neo4j graph must have a type. This allows us to choose at query time which part of the graph we will traverse.

For example, we can traverse through every relationship from Michael, or we can specify the `MARRIED_TO` relationship to end up only at Sarah’s node.

Here are sample Cypher statement statements to support this:

```cypher
// traverse the Michael node to return the Sarah node
MATCH (p:Person {firstName: 'Michael'})-[:MARRIED_TO]-(n) RETURN n;
// traverse the Michael node to return the Graph Inc node
MATCH (p:Person {firstName: 'Michael'})-[:WORKS_AT]-(n) RETURN n;
// traverse all relationships from the Michael node
// to return the Sarah node and the Graph Inc node
MATCH (p:Person {firstName: 'Michael'})--(n) RETURN n
```

#### Relationship properties

As with nodes, relationships can also have properties. These can refer to a cost or distance in a weighted graph or just provide additional context to a relationship.

![Relationship properties](/img/neo4j/rp.png)

In our graph, we can place a property on the `MARRIED_TO` relationship to hold the date in which Michael and Sarah were married. This `WORKS_AT` relationship has a roles property to signify any roles that the employee has filled at the company. If Michael also worked at another company, his `WORKS_AT` relationship to the other company would have a different value for the roles property.

## Native Graph Advantage

### Neo4j is a native graph database

Neo4j is a native graph database, meaning that everything from the storage of the data to the query language have been designed specifically with traversal in mind. Just like any other enterprise DBMS, Neo4j is **ACID** compliant. A group of modifications in a transaction will all either commit or fail.

Where native graph databases stand apart from other databases is the concept of **index-free adjacency**. When a database transaction is committed, a reference to the relationship is stored with the nodes at both the start and end of the relationship. As each node is aware of every incoming and outgoing relationship connected to it, the underlying graph engine will simply chase pointers in memory - something that computers are exceptionally good at.

### Index-free adjacency (IFA)

One of the key features that makes Neo4j graph databases different from an RDBMS is that Neo4j implements **index-free adjacency**.

### Neo4j storage

With index-free adjacency, Neo4j stores nodes and relationships as objects that are linked to each other via pointers. Conceptually, the graph looks like:

![storage](/img/neo4j/n4js1.png)

These nodes and relationships are stored as:

![storage](/img/neo4j/n4js2.png)

### Neo4j Cypher statement

Suppose we had this query in Cypher:

```cypher
MATCH (n) <-- (:Group) <-- (:Group) <-- (:Group {id: 3})
RETURN n.id
```

Using IFA, the Neo4j graph engine starts with the anchor of the query which is the Group node with the id of 3. Then it uses the links stored in the relationship and node objects to traverse the graph pattern.

![storage](/img/neo4j/n4js3.png)

To perform this query, the Neo4j graph engine needed to:

1. Plan the query based upon the anchor specified.
2. Use an index to retrieve the anchor node.
3. Follow pointers to retrieve the desired result node.

The benefits of IFA compared to relational DBMS access are:

- Fewer index lookups.
- No table scans
- Reduced duplication of data.

## Non-graph Databases to Graph

### Benefit of Neo4j over Relational

As mentioned in the last lesson, index-free adjacency is a huge differentiator between relational and graph databases. While relationships are stored at write-time in a graph database, the joins made in a relational database are computed at read-time. This means that, as the number of records in a relational database increases, the slower the query becomes. The query time in a graph database will remain consistent to the size of the data that is actually touched during a query.

Having relationships treated as first class citizens also provides an advantage when starting out. Modelling relationships in a graph is more natural than creating pivot tables to represent many-to-many relationships.

### Northwind RDBMS to graph

Let’s look at the Northwind RDBMS data model.

![storage](/img/neo4j/ngd1.png)

In this example, an order can contain one or more products and a product can appear in one or more orders. In a relational database, the Order Details table is required to handle the many-to-many relationships. The more orders added, and subsequently the larger the Order Details table grows, the slower order queries will become.

![storage](/img/neo4j/ngd2.png)

In a graph, we can simply model a CONTAINS relationship from the Order node to each Product node. The Product node has a unit price property and the CONTAINS relationship which has properties to represent the quantity and discount.

### NoSQL datastores to graph

NoSQL databases solve many of the problems, and they are great for write throughput.

But there are problems with how data is queried. The two most common NoSQL databases represent key/value stores and documents.

#### Key-value stores

![storage](/img/neo4j/ngd3.png)

The **key-value** model is great and highly performant for lookups of huge amounts of simple or even complex values. Here is how a typical key-value store is structured.

#### Key-value as a graph

However, when the values are themselves interconnected, you have a graph. Neo4j lets you traverse quickly among all the connected values and find insights in the relationships. The graph version shows how each key is related to a single value and how different values can be related to one another (like nodes connected to one another through relationships).

![storage](/img/neo4j/ngd4.png)

#### Document stores

![storage](/img/neo4j/ngd5.png)

The structured hierarchy of a Document model accommodates a lot of schema-free data that can easily be represented as a tree. Although trees are a type of graph, a tree represents only one projection or perspective of your data. This is how a document store hierarchy is structured as pieces within larger components.

#### Document model as graph

![storage](/img/neo4j/ngd6.png)

If you refer to other documents (or contained elements) within that tree, you have a more expressive representation of the same data that you can easily navigate using a graph. A graph data model lets more than one natural representation emerge dynamically as needed. This graph version demonstrates how moving this data to a graph structure allows you to view different levels and details of the tree in different combinations.

## Explore Neo4j

### The Movie Graph

GraphAcademy has created a Neo4j sandbox instance for you. The graph contains a dataset of movies and people.

In this lesson, you will explore the graph and use Cypher to query it.

#### Nodes

The graph contains nodes labeled `Movie` and `Person`.

Neo4j includes a query language called Cypher that allows you to query the graph.

Run the following Cypher query to return the first 50 `Movie` nodes in the graph:

```cypher
MATCH (m:Movie) RETURN m LIMIT 50
```

You will see the `Movie` nodes returned as a graph.

Click on a node to see it’s properties. `Movie` nodes have properties like `title`, `released`, and `plot`.

Try modifying the query to return `Person` nodes instead of `Movie` nodes.

```cypher
MATCH (p:Person) RETURN p LIMIT 50
```

:::note All notes
You can return all the nodes by removing the LIMIT clause. It may take longer to return all the nodes.
```cypher
MATCH (m:Movie) RETURN m
```
:::

You can filter the nodes returned by adding a condition to the query. For example, you can filter `Movie` nodes by the `title` property.

```cypher
MATCH (m:Movie {title: 'Toy Story'}) RETURN m
```

#### Relationships

The relationships between nodes describe how people are related to movies. For example, Person nodes have `ACTED_IN` and `DIRECTED` relationships with `Movie` nodes.

Run this Cypher query to return the `Movie` node 'Hoffa' and `Person` nodes with an `ACTED_IN` relationship to the movie:

```cypher
MATCH (m:Movie {title: 'Hoffa'})<-[r:ACTED_IN]-(p:Person)
RETURN m, r, p
```

The movie 'Hoffa' is a `Movie` node with relationships to `Person` nodes who acted in and directed the movie.

The query doesn’t include the `DIRECTED` relationship, but it appears in the graph.

Neo4j will also display other relationships between the returned nodes to give a complete view.

:::note View relationships
You can double-click on nodes in the graph to expand their relationships with other nodes.
:::

#### Properties

Nodes have properties that describe them. For example, `Person` nodes have properties like `name` and `born`, `Movie` nodes have properties like `title` and `released`.

Relationships in Neo4j can also have properties, the `ACTED_IN` relationship has a role property, storing the person’s role in the movie.

Run the following Cypher to return the movie title and person’s name who acted in the movie "Top Gun":

```cypher
MATCH (m:Movie {title: 'Top Gun'})<-[r:ACTED_IN]-(p:Person)
RETURN m.title, p.name
```

Note how the query returns the data as a table, rather than a graph, of the movie title and person’s name.

### Get Neo4j

There are many options to use Neo4j, including a fully hosted cloud solution ([AuraDB](https://neo4j.com/cloud/platform/aura-graph-database/)), local installations, and Docker containers.

In this lesson, you will explore some of these options.

#### Community and Enterprise Editions

There are two editions of Neo4j to choose from, the Community Edition (CE) and the Enterprise Edition (EE). The Enterprise Edition includes all Community Edition offers, plus extra enterprise requirements such as backups, clustering, and failover capabilities.

The **Community Edition** is a fully functional edition of Neo4j, suitable for single-instance deployments. It fully supports key Neo4j features, such as ACID-compliant transactions, Cypher, and programming APIs. It is ideal for learning Neo4j, do-it-yourself projects, and applications in small workgroups.

The **Enterprise Edition** extends the functionality of Community Edition to include key features for performance and scalability, such as a clustering architecture and online backup functionality. Additional security features include role-based access control and LDAP support, for example, Active Directory. It is the choice for production systems with requirements for scale and availability, such as commercial and critical internal solutions.

The [Neo4j Editions documentation](https://neo4j.com/docs/operations-manual/current/introduction/#_neo4j_editions) includes a comparison of the features available in each edition.

#### AuraDB

[AuraDB](https://neo4j.com/cloud/platform/aura-graph-database/) is a fully managed cloud service that provides a Neo4j database as a service. It is a fully managed, scalable, and secure cloud database service that allows you to focus on building applications without worrying about the operational aspects of managing a database.

You can create a free Neo4j instance at console.neo4j.io and scale it up or down as needed. AuraDB is available in multiple regions, and you can choose the region that best fits your needs.

#### Installation

You can install Neo4j on most platforms, including Linux, macOS, and Windows. The [Neo4j Installation documentation](https://neo4j.com/docs/operations-manual/current/installation/) provides detailed instructions for each platform.

In addition, Neo4j provides a Desktop development tool that includes a local installation of Neo4j, a browser-based interface, and a set of tools to help you develop and manage your Neo4j databases. Installation and usage instructions are on the [Neo4j Desktop download](https://neo4j.com/download/) page.

#### Cloud deployments

Neo4j’s cloud marketplace listings represent a quick and easy way of getting started with graph databases on the cloud platform of your choice.

You can find more information in the [Neo4j Cloud deployments documentation](https://neo4j.com/docs/operations-manual/current/cloud-deployments/).

#### Docker

Neo4j provides Docker images for both the Community and Enterprise editions.

The [Neo4j Docker documentation](https://neo4j.com/docs/operations-manual/current/docker/) provides instructions on how to run, configure, and deploy Neo4j in a Docker container.

#### Get Started

The right Neo4j deployment option will depend on your requirements. [Neo4j AuraDB](https://console.neo4j.io/) and [Neo4j Desktop](https://neo4j.com/download/) provide the easiest way to start with Neo4j.